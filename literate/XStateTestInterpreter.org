#+TITLE: XState Test Interpreter
#+PROPERTY: header-args    :comments both :tangle ../src/xstate-test-interpreter.js

* Usage
:PROPERTIES:
:header-args: :tangle no
:END:

The following is example code of how one might use this.

Import along with XState:

#+begin_src js
import { TestInterpreter } from "xstate-test-tools"
import { Machine } from "xstate";
#+end_src

Make a new XState machine as normal.

#+begin_src js
const machine = Machine({
        id: "myMachine",
        initial: "in",
        states: {
            in: { on: { OUT: "out" } },
            out: { on: { IN: "in" } }
        }
    });
#+end_src

Instantiate the interpreter with that machine

#+begin_src js
const interpreter = TestInterpreter(machine);
#+end_src

Access initial state and context before transitioning.

#+begin_src js
console.log(`Initial state: ${interpreter.S}`);
console.log(`Initial context: ${interpreter.C}`);
#+end_src

The above is convenient shorthand for the equivalent:

#+begin_src js
console.log(`Initial state: ${interpreter.state}`);
console.log(`Initial context: ${interpreter.state.context}`);
#+end_src

Send an event just like XState's built-in interpreter:

#+begin_src js
interpreter.send("OUT");
interpreter.send({ type: "OUT" }); // Same as above
#+end_src

Inspect later state the exact same way as initial state:

#+begin_src js
console.log(`New state: ${interpreter.S}`);
console.log(`New context: ${interpreter.C}`);
#+end_src

* Implementation

I'm averse to the =new= keyword, so the actual export will be a wrapper for that:

#+begin_src js
export const TestInterpreter = (...args) => {
    return new _TestInterpreter(...args);
}
#+end_src

Now the internal implementation as a =class=.

#+begin_src js
class _TestInterpreter {
#+end_src

Using XState, referencing =machine.state= and =machine.state.context= is so common that I like to use shorthand, =interpreter.S= and =interpreter.C= respectively.

When the machine has just been instantiated, =machine.initialState= is actually the only state.

#+begin_src js
    constructor(machine) {
        this.machine = machine;
        this.state = machine.initialState;
        this.S = this.state;
        this.C = this.state.context;
    }
#+end_src

To affect a change, the user will =send= an =event=.

When a transition occurs, we also execute any actions described as side effects. See [[https://xstate.js.org/docs/guides/interpretation.html#custom-interpreters][XState Custom Interpreters]] for more info.

#+begin_src js
    send (event) {
        this.state = this.machine.transition(this.state, event);
        this.S = this.state;
        this.C = this.state.context;

        // Get the side-effect actions to execute
        this.state.actions.forEach(action => {
            // If the action is executable, execute it
            action.exec && action.exec(this.C, event, { state: this.state });
        });
    }
#+end_src

Wrap up the class definition:

#+begin_src js
}
#+end_src
